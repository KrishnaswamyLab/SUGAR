function Y = sugar(data,varargin)
% SUGAR   Geometry-based Data Generation    https://arxiv.org/abs/1802.04927
%   Authors: Ofir Lindenbaum, Jay S. Stanley III.
%
% Usage:
%         Y = sugar(data, varargin) Generate Y using estimated manifold geometry over data
%         
% Input: 
%       data           
%               N x D Data matrix. N rows are measurements, D columns are features.
%                   Accepts: 
%                       numeric
%
%   varargin:
%       noise_cov        (default = 'knn')
%               Bandwidth of Gaussian noise.
%                   Accepts:
%                       'knn' - (local covariance estimation for tuning noise)
%                       scalar - constant noise bandwidth
%
%`      noise_k      (default = 5)
%               Neighborhood size for covariance estimation
%                   Accepts:
%                       positive scalars
%           
%       kernel_sigma    (default = 'std')
%               Diffusion kernel bandwidth. 
%                   Accepts:    
%                        'std'- standard deviation of the distances
%                        'knn' - adaptive bandwidth,eg  kth neighbor distance
%                        'minmax'-  min-max on the distance matrix       
%                        'median'- the median of the distances      
%                         function handle - @(d) f(d) = scalar or N-length 
%                                   vector where d is an NxN distance matrix.    
%                         scalar - pre-computed bandwidth
%
%       kernel_k         (default = 5)
%               k-Nearest neighbor distance to use if kernel_sigma = 'knn'
%               Accepts:
%                       positive scalars
%       
%       M               (default = 0)
%               Number of points to generate.  Can affect strength of density
%               equalization.
%                   Accepts: 
%                        positive scalars 
%                        If (M && equalize) then density equalization will be
%                        scaled by M.  M < N will negatively impact density
%                        equalization, M << N is not recommended and M <<< N may fail.
%                        If (~M && equalize) then density equalization will not be
%                        scaled
%                        If (M && ~equalize) then approximately M points will be
%                        generated according to a constant difference of the
%                        max density
%                        If (~M && ~equalize) then M = approx. N points will be
%                        generated.
%
%       equalize        (default = false)
%               Density equalization.  Can be affected by M.
%                   Accepts: 
%                       logical / scalar
% Output:
%      Y 
%               M x D New points generated by SUGAR
%    
disp('Initializing SUGAR')
[data, params] = init(data, varargin{:});


%Estimate the degree
disp('Obtaining Degree Estimate')
[d_hat, s_hat, sigma] = degrees(data, 'kernel_sigma', params.kernel_sigma, 'k', params.k);
params.kernel_sigma = sigma;

%If no parameter for noise covariance is given then estimate local covariance
if strcmp(params.noise_cov, 'knn')
    disp('Local Covariance estimation')
    [noise] = local_covariance(data,'k',params.noise_k);
    params.noise_cov = noise;
end

%Estimate number of points to generate around each original point
disp('Estimating number of points to generate')
[npts] = numpts(d_hat, 'noise_cov', params.noise_cov, 'kernel_sigma', params.kernel_sigma, 'dim', params.dim,'M', params.M, 'equalize', params.equalize);

%Generate points 
disp('Generating points')
random_points=generate(data,npts,noise_cov);

%Compute and apply mgc magic
disp('Diffusing points via MGC MAGIC')
Y = mgc_magic(data,random_points,s_hat,varargin{:,:});



end

function [data, params] = init(data, varargin)
% initialization & parameter parsing
% SUGAR DEFAULTS
    default.noise_cov = 'knn';
    default.kernel_sigma = 'std';
    default.k = 5;
    default.M = 0; % we will check this later and change it to be based on the data size N
    default.equalize = false;
    
    
% type checking
    function tf = check_sigma(passed)
    % check that diffusion sigma is correct type
        valid_sigmas = {'std','knn', 'minmax', 'median'};
        if isscalar(passed) || isa(passed, 'function_handle') || ... %user supplied sigmas 
            any(cellfun(@(x) strcmp(passed,x), valid_sigmas))  % predefined sigma options
            tf = true;
        else
            tf = false;
        end
    end

    function tf = check_noise(passed)
    % check gaussian noise noise
        if isscalar(passed) || strcmp(passed, 'knn')
            tf = true;
        else 
            tf = false;
        end
    end

    scalarPos = @(x) isscalar(x) && (x>0);
    persistent p
    if isempty(p)
        %configure parser
        p = inputParser;
        addRequired(p, 'data', @isnumeric);
        addParameter(p, 'noise_cov', default.noise_cov, @check_noise);
        addParameter(p, 'noise_k', default.k, scalarPos);
        addParameter(p, 'kernel_sigma', default.kernel_sigma,@check_sigma);
        addParameter(p, 'kernel_k', default.k, scalarPos);
        addParameter(p, 'M', default.M, scalarPos);
        addParameter(p, 'equalize', default.equalize, @isscalar);
    end
    % parse
    parse(p,data, varargin{:})
    
    data = p.Results.data;
    params = p.Results;
    params = rmfield(params,data);
    params.dim = size(data, 2);
    
end